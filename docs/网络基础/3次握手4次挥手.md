测试环境：

![图形用户界面, 文本  中度可信度描述已自动生成](..\img\3次握手4次挥手\clip_image002.jpg)

测试动作：

PC访问web服务器，先与服务器进行TCP连接，连接后访问server端http服务，关闭页面时，断开TCP连接。

 

1.使用wireshark抓包，分析TCP协议结构 

wireshark抓包如下：

![img](D:\icq\t0m4to.github.io\docs\img\3次握手4次挥手\clip_image004.jpg)

可以看到抓到了PC与Server端建立TCP连接到断开连接的所有数据包，包括TCP三次握手、四次挥手和http协议数据包。



 

TCP协议数据包分析：

![img](D:\icq\t0m4to.github.io\docs\img\3次握手4次挥手\clip_image006.jpg)

这是PC与Server端建立连接生成的第一个TCP连接请求包，包含源端口号，目的端口号及校验信息等，确保端到端的可靠传输。

TCP协议结构分析：

![表格  描述已自动生成](D:\icq\t0m4to.github.io\docs\img\3次握手4次挥手\clip_image008.jpg)

​    TCP是一种面向连接、可靠的、基于字节流的传输层通信协议。

​    TCP协议主要特性有：面向连接的传输协议、仅支持单播、提供可靠的交付服务、传输单位为数据段，支持全双工传输、基于字节流而非报文流、每次传输的数据段大小和数据段数都是可变的。

​    源端口(S port)和目的端口(D port)：各16位，端口范围1-65535（2^16-1），一般由本地随机一个源端口与一个固定目的端口建立通讯，目的端通过端口向访客提供服务。

​    序号(seq)：占32位，在TCP连接中，传输的数据字节流中的每一个数据字节都要按顺序编号；序号是数据段第一个数据字节的编号，比如一个数据段序号是201，数据段共有100字节，说明这个数据段最后一个字节的编号是300；下一个数据段的序号应该是301.

​    确认号（ack）：指希望收到对方第一个数据包的“数据”部分第一个字节序号，比如确认号是201，则表示到序号201-1为止的所有数据已经接收成功。**TCP****可靠传输**

​    数据偏移（Header length）：占4位，即首部长度，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。

​    保留（Reserverd）：占6位，保留为今后使用，目前应置为0.

​    紧急URG：占1为，紧急指针控制位。

​    确认ACK：占1位，确认控制位，当ACK=1则表示确认字段有效，负责表示确认号（ack）无效。

​    推送PSH：占1位，推送控制位。确认是否需要把收到的数据段提交给应用程序，当PSH=1，则要求接收端尽快把该数据段提交给应用程序，当PSH=0，可以先缓存起来。

​    复位RST：占1位，重置控制位。用于重置、释放一个已经混乱的传输连接，然后重建新的传输连接，当RST=1时，会释放当前传输，然后重新建立新的传输。**TCP****重传机制**

​    同步SYN：占1位，同步控制位。在传输建立连接时，同步传输连接序号。当SYN=1时，表示这是一个请求连接或连接接收报文。

​    终止FIN：占1位，final控制位。用于释放连接，当FIN=1，表示当前报文段发送端的数据已经发送完毕，并要求释放运输连接。

​    窗口字段（Windows）：占16位，指发送此TCP数据段的主机上用来存储传输数据段的窗口大小，即发送者当前还可以接收的最大字节数。例如发送的数据段确认号字段是501，而窗口大小字段的值是100，则从501开始算，本端还可以接收100字节（字节序号501-600）。

​    校验和：占16位，校验和字段的检验范围，包括首部和数据两部分，在计算校验和时，要在TCP报文段前加上12字节的伪首部。

​    紧急指针字段：占16位，指出在本报文段中紧急数据共有多少个字节，只有URG=1时才有意义。

​    

2.分析TCP三次握手和四次挥手过程（重点，推荐有能力的同学画相关流程图帮助理解记忆）

三次握手数据包：

![图片包含 文本  描述已自动生成](D:\icq\t0m4to.github.io\docs\img\3次握手4次挥手\clip_image010.jpg)

​    PC与Server进行交互前建立的TCP连接，只有建立连接完成，才能进行基于传输层TCP协议传输的应用层http协议数据包。

 

 

四次挥手数据包：

![img](D:\icq\t0m4to.github.io\docs\img\3次握手4次挥手\clip_image012.jpg)

此时PC关闭web页面，向Server端发送断开连接的请求，在四次挥手完成后，PC与Server断开连接，本次客户端访问web交互完成。

​    

关于四次挥手实际只抓到三个包：

由于实验中PC与web之间产生数据交互比较少，当PC发送FIN=1时，会告知Server端已经没有数据要发送过去了，并关闭PC自己的数据发送通道。

但因为TCP的双通道机制，此时PC数据接收通道并没有关闭，所以不影响Server端继续发送数据包到PC。

当Server端接收到PC断开请求包，也会关闭自己的接收通道，此时如果Server端同样没有数据发送到PC，Server端也会同时发送FIN=1给PC请求断开连接，这个时候就出现了ACK和FIN合并的情况，所以wireshark实际只抓到三个包而不是理论上的四个包。

若在收到PC断开请求时Server端仍有数据在发送，则会先发送ACK=1的包给PC进入连接半关闭状态，等数据发送完再发送FIN=1断开连接，这个时候四次挥手就是四个包了。

这也是协议开发者为了提高效率有意做的合并机制。



测试中完整连接交互过程：

![img](D:\icq\t0m4to.github.io\docs\img\3次握手4次挥手\clip_image014.jpg)